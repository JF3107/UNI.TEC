
*******************************【promise】******************************
promise 是JS异步编程的解决方案（传统:回调函数+事件），ES6原生提供Promise对象。
----
Promise，一个容器：保存着某个未来才会结束的事件[ 通常为异步操作 ]的结果。(保存着结果)
----
两个特点：
①对象状态不受外界影响：[三种状态] pending进行中.fulfilled已成功.rejected已失败。
  有且只有异步操作的结果 能决定当前是哪种状态。（Promise，"承诺",, 其他任何操作都无法改变这个状态）
②一旦改变.不会再变：Promise对象状态改变、只有两种可能：pending->fulfilled 或者 pending->rejected。
  只要这两种状态发生，就凝固了、不会再变。
  ** 如果改变已经发生、再对Promise添加回调函数, 也立即得到那个结果。（这与"事件"不一样：事件错过了再监听..是没结果的）
----
三个缺点：
①无法取消Promise[一旦新建.立即执行] ②若不设回调、Promise内部抛出错误.不会反应到外部 ③pending状态时.无法得知进展阶段
==== ====
Promise 构造函数, 接受一个函数( 带有resolve/reject两个参数[js引擎提供] )作为参数。
  》 const promise = new Promise(function(resolve,reject){ ......})
promise 实例生成后, 用then方法分别指定resolve/reject状态的回调函数 》 p.then(function(v){成功},function(v){失败 >>可选的})
**** Promise API ****
Promise.prototype.then()  也就是 那个then（可接受两个函数作为参数[成功+失败]）
Promise.prototype.catch()  是 .then(null, rejection)的别名
Promise.prototype.finally() 不管Promise对象最后的状态如何.都会执行的操作（ES2018引入的）
Promise.all()  使用 >>> Promise.all([p1,p2,p3]) 全fulfilled才总fulfilled，只要一个rejected、整个rejected；P.all.then(...)
Promise.race()  使用 >>> Promise.race([p1,p2,p3]) 的p1p2p3...中,只要有一个成功/失败,就触发!；P.race.then(...)



*******************************************************************************
*******************************************************************************


+++++++++（Set）++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
【去重版 数组】
数据结构 Set：（类似数组，但没有重复的成员）
Set是一个构造函数，用来生成Set数据结构。
Set可以接受一个数组（或具有iterable接口的其他数据结构）作为参数。用来初始化。
---------
set.add(value)    添加
set.delete(value)   删除
set.has(value)    查询(返回布尔值)
set.clear()    清空所有成员
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 
**************************************************************************************************
 
 
 
+++++++++（Map）++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
【增强版 对象】
数据结构 Map：（类似对象，但“键”不限于字符串）
[ Object提供了“字符串-值”对应，  Map提供了“值-值”对应（Map是一种更完善的哈希结构实现） ]
Map是一个构造函数，用来生成Map数据结构。
----------
map.set(键，值)   增加键值
map.get(键)     按键取值 
map.has(键)     查询（返回布尔值）
map.delete(键)    删除键值
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 
**************************************************************************************************
 
 
 
+++++++++（import）+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ES6的模块功能，完全可以取代AMD/CommonJS，成为浏览器/服务器通用的模块加载解决方案。
---------
【import】：
import { stat, exists, readFile } from 'fs';
（CommonJS加载实质是：整体加载(比如说)fs模块，生成一个对象，再从其上读取三个方法）
ES6的模块加载实质是：从fs模块加载3个方法（其他方法不加载），这叫“静态加载/编译时加载”
  ES6编译时就完成了模块加载（效率比CommonJS高）、但它无法引用模块本身（因为没“生成对象”）
---------
【export】：
export的两个方法：
export var aaa = "a";
export var bbb = "b";  
或
export {aaa, bbb};
export {aaa as 1a, bbb as 2b};
--------
## 错误/正确：
（export对外输出的是接口、不是值。）
export 1;       错
export var m = 1;  对  // 整个 var m = 1;  是接口
----
var m = 1;
export m;      错 // 1是值、不是接口
var m = 1;
export {m};     对  // 用{}括起的变量是接口（--0226观点）
--------
export还能输出 函数/类
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 
**************************************************************************************************
 
 
+++++++++（class）++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
【类】：
class PPP {
   constructor(x,y){}  //constructor方法、默认存在、new时用
   toString(){}     //类 所具有的/定义的 其他方法
   ...
}
（实例的属性除非显式定义在其本身[ 用this ]，否则一概定义在原型上）
【继承】：
class SubPPP extends PPP {
   constructor(x,y,color){
      super(x,y);
      this.color = color;
   }
   toString(){
      ...
      ...super.toString()...
   }
}
**  super关键字表示父类构造函数：
        super(x,y)就是PPP中的constructor。
        super.toString()就是父类构造函数的那个toString()方法
!!!  子类必须在constructor方法中调用super方法，否则报错。（其他类中方法不一定用到super、但constructor必须！）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 
**************************************************************************************************
 
 
 
+++++++++（promise）++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
★概念，Promise：【Promise对象是一个构造函数，用来生成Promise实例】
（异步编程的一种解决方案  << 传统解决方案是“回调函数”）
它是一个容器，里面保存着某个 未来才会结束的 事件的 结果。（通常是一个异步操作）
它是一个对象，提供统一的API，各种异步操作都可以用同样的方法进行处理。
---
特征1：不受外界影响。
（>>  Promise对象 代表一个 异步操作，有三个状态[pending进行中/fulfilled已成功/rejected已失败]）
（>>  只有异步操作的结果可以决定当前是哪一种状态。任何其他操作都无法改变这个状态。）
特征2：一旦状态改变，就不会再变，任何时候都可以得到这个结果。
（>>  一共2个可能：从pending变为fulfilled；从pending变为rejected）
（>>  只要这两种情况一发生、就凝固，不会再变。即 “resolved（定型）”）
-----------------------------
☆Promise的使用：
###  首先，利用构造函数Promise创建Promise实例：
const promise = new Promise(function(resolve, reject){...成功：resolve(value)，失败reject(error)...})
（这里 value，error都是Promise对象传出的值）
###  Promise实例生成后，可以使用then  >>  分别指定 resolve/reject状态的回调函数：
promise.then(function(value){成功后的逻辑}, function(error){失败后的逻辑})
（其中第二个参数(失败-回调)，可省！）
 
【0225：/时间原因。promise强攻视为完成。promise盾构推进时，需要重新覆盖】
 
**************************************************************************************************
 
 
 
+++++++++（箭头函数）+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
★ 概念：ES6允许使用 “=>”定义函数。箭头函数。例如：  var f = v => v  //即 var f = function (v){ return v; };
**  箭头函数不需要参数/需要多个参数，用小括号： () => 2     (x,y) => x+y
**  箭头函数的代码块多于一条语句，用大括号、并在最后写上return： () => {.....}
**  没有return滴返回对象如用到“大括号”，需要在大括号外面加小括号（因为大括号被理解成代码块）：...=>({x:"", y:""});
 
☆ 用处：①使表达更加简洁 ②简化回调函数
 
☆ 箭头函数使用注意点：
  ① 函数体内的this对象：是定义时所在的对象、而不是使用时所在的对象。
    （↑↑↑， 第一句：普通函数中的this指向是可变的，箭头函数中的this指向是【固定】的）
    （↑↑↑， 第二句：函数中的普通函数中的this，指向全局对象。函数中的箭头函数中的this，指向定义该函数的对象）
    （↑↑↑， 第三句：箭头函数根本没有this，箭头函数中的this就是外层代码块的this。所以箭头函数不可用作构造函数）
    （↑↑↑， 第四句：不管嵌套多少层箭头函数，this还是最外层箭头函数外的那个函数的this）
  ② 不可作 构造函数。（一旦用new，即报错误）
  ③ 不可使用 arguments对象。（可用“rest参数[ 也就是  ...xxx ]”代替）
  ④ 不可使用 yield命令。（也就是，箭头函数不能用作Generator函数）
    （除了this，  argument、super、new.target也是箭头函数中不存在的，指向外层函数的对应变量）
 
☆ 箭头函数：可嵌套
 
【0225：箭头函数强攻完成。“函数扩展”盾构推进时，可跳过箭头函数区】
 
*************************************************************************************************
 
 
------------------------------------------------------------------------------------------------------------------------------
===========================（以下是  ES6盾构区）==============================================================================
------------------------------------------------------------------------------------------------------------------------------
 
 
C 3 变量的解构赋值
=======================================
★概念：【解构-Destructuring】ES6允许按照一定模式，从【数组/对象】中提取值、对变量进行赋值。
（模式相同，就能解构赋值）
 
数组的解构赋值
--------------------
  let [a,b,c] = [1,2,3]   （左右数组元素一一对应） //a==1 b==2 c==3
** 对于“可遍历结构”，均可以：成功解构/不完全解构/解构失败（赋undefined）。
    比如 Set结构、也可以使用数组的解构赋值。
** “不可遍历结构”则报错。
 
对象的解构赋值
--------------------
  let {foo, boo} = {foo:"111", boo:"222"}  （左右对象属性排列无序、属性名一致即成功赋值）//foo=="111" boo="222"
** let {a, a:[x,y]} = {a:['xxx','yyy']}  // a==['xxx','yyy']  x=='xxx'  y='yyy'
（其中，上面let区内，第一组的a是变量、第二组的a是模式、第二组中的x、y才是变量）
** 一定要分清 模式、变量（“：”前面的都是模式），模式 不参与解构赋值！
 
字符串的解构赋值
--------------------
（第一步：先转为对象！）
  const [a,b,c,d,e] = "hello"  （字符串这时被转化成“类数组对象”） // a=="h"  b=="e"  c=="l"  d=="l"  e=="o" 
  let {length: len} = "hello"  （这个“类数组对象”还有一个length属性） // len == 5
  
数值/布尔值/null/undefined的解构赋值
--------------------
（第一步：先转为对象！）
数值/布尔值可以转对象：  let {toString: s} = 123/true    //  s 就是那个toString方法
null/undefined无法转对象：  所以报错
 
函数参数的解构赋值（也可设默认哦）
--------------------
版本1: （数组作为参数，解构赋值）
function add([x,y]){  return x+y;  }   >>   add([1,2])   // 3
版本2：（对象作为参数，解构赋值）
function wtf({x=0, y=0}={}){  return [x,y]  }   >>   wtf() // [0,0] 】wtf({}) // [0,0] 】wtf({x:3}) // [3,0] 】wtf({x:2,y:8}) // [2,8]
 
圆括号问题
--------------------
不要对“模式”用圆括号。
 
用途
--------------------
①交换变量的值
②从函数返回多个值（函数return数组、用数组去接）
③函数参数的定义（用[..有序参.]或{..无序参.}作为参数/传参）
④提取JSON数据  （let {a:i, b:j} = JSON对象，  用来提取JSON中a、b属性）
⑤指定函数参数的默认值
⑥遍历Map结构   （  套用for...of遍历：   for(let [k,v] of map实例){..使用变量k和v.}  ）
...
 
 
 
C 2 let & const
=======================================
 
let
--------------------
let：声明 块级作用域的变量（{...}内有效）  << 类似于var
** for循环的计数器i，适合用let声明（不会污染到循环体外）。且：
for循环-设置部分是 父作用域
for循环-循环体内是 子作用域
** let不存在变量提升（声明前使用会报错）
** TDZ-暂时性死区：let声明前该变量在块区内被锁定，不能赋值、不能使用
** 不允许重复声明（let-let X, let-var X, var-let O）
 
块级作用域
--------------------
块级作用域：
ES5，无块级作用域：产生不合理现象 ①内层变量覆盖外层变量 ②循环变量泄漏
ES6，有块级作用域：规则 ①各层块区内均可let声明变量 ②同层块区内不可重复声明
块域与函数声明：
ES5，只可在顶层/函数作用域中声明函数。
ES6，①允许块中声明函数、但有兼容条款：
 ②函数声明类似于var 
 ③函数声明会提升至块区头部
所以：尽量不要在块级作用域中声明函数！
（实在有需求，也应该用“函数表达式 let ff = func(){}”而不是“函数声明 func ff(){}”）
 
const
--------------------
const：声明一个只读的常量。（①一旦声明、其值不得改变 ②声明后应立即初始化）
（同let：①块级作用域、②有TDZ、③不可重复声明）
本质：const 保证 变量指向的那个内存地址不得改动。
** 对基本类型[那个内存地址，就是值]  完全保证不可变性
** 对复杂类型[那个内存地址，只是指针]  不保证指针所指对象可变性
（ 真想常量化/固化，用冻结：Object.freeze(...) ）
 
ES6，六种声明变量的方法
--------------------
var（ES5）  function（ES5）  let  const  import  class
 
顶层对象 的属性
--------------------
浏览器：window对象
NodeJS：global对象
ES5中，顶层对象的属性 与 全局变量  等价。
ES6起，顶层对象的属性 与 全局变量  将逐步脱钩。
**  var/function声明变量仍旧是顶层对象的属性
**  let/const/class声明变量不属于顶层对象的属性
 
 
 
C 1   ES与JS，ES6=ES2015（ES6泛指下一代JS语言）
 
 
 
C 0   X