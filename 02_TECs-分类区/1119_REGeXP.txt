

正则表达式：
****************************************************************
<<<<<<<< 




<<<<<<<< 0524

#  new RegExp("[\u4e00-\u9fa5]")是什么意思？ <<  匹配所有汉字。
**  “\u4e00”和“\u9fa5”是unicode编码,并且正好是中文编码的开始和结束的两个值。

#  正则的一些方法：
-----
正则/字串-查找：待操作str.search( reg/str )  >>>  推荐：str.search(reg)，返回首次匹配的那个index
正则/字串-替换：待操作str.replace( reg/str, 待替换str )
正则-验证：reg.test("待验证")
正则-匹配取出：reg.exec("待取出")  >>>  匹配、返回数组；不匹配 、返回null
字串-匹配取出：str.match(reg)         >>>  匹配、返回数组；不匹配 、返回null
（match / exec 使用有细微差别、参考：https://www.cnblogs.com/hyaaon/p/4332678.html）

<<<<<<<< 0420+

# //i[i.gnore 不区分大小写],  //g[g.lobal 全局匹配]  >> //ig.不区分大小写+全局匹配，//m.ore-多行匹配，...

++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++

>>>>>>>>【概念】
没啥好说，直接上"运用"！


>>>>>>>>【运用】
/xxx/i   （忽略模式）   >> 忽略大小写 - abc ABC AbC
/xxx/g  （全局模式）  >> 匹配全局[ 已经找到匹配项后..继续寻找 ]
/xxx/    （普通模式）  >> 匹配单个[ 找到匹配项后..不再寻找 ]
.                 >> .(点)，匹配除\n、\r外任何单个字符
   ---------  >> 一个字母、一个点"."，当然就是匹配一个对象(字母/符号)
+                >> 匹配一次以上
*                 >> 任意次（0+）
?                 >> [xxx]? - 匹配前面的"子表达式" 0次 或 1次（非贪婪）[!!!!   +? >>  一次以上+最多一次="有且仅有一次"]
^                 >> 首
$                 >> 尾
$1, $2         >> 前序 “( )”，第一个小括号对应$1、第二个对应$2、以此类推
?:                >> (?:xxx) - "非捕获元"字符，用来重写捕获、忽略对相关匹配的保存
\                  >> 用于"转义"
\s                >> 匹配任何不可见字符=>等价于[ \f\n\r\t\v] ~  \f换页符 \n换行符 \r回车符 \t制表符 \v垂直制表符
\S                >> 匹配任何可见字符=>等价于[^ \f\n\r\t\v]
{n}               >> 匹配2次，精确数字；例如：x{2}
{n,}              >> 至少匹配n次，即n+；例如：x{2,}
{n,m}           >> n<=m, 最少匹配n次、最多匹配m次（有多少匹配多少..至多不超过m次）；例如：x{2,3}
x|y               >> 匹配：x或y一格
[xy]              >> 匹配：x或y一格
[^xy]             >> 匹配：非x且非y一格[负值字符集合]
[a-z]             >> 匹配：a-z字母一格
[a-zA-Z0-9]       >> 匹配：a-zA-Z0-9(全部大小写字母+数字)一格


>>>>>>>>【集中营】
-------------------------------------------------
【1】str.replace(/(^\s+)|(\s+$)|(\s+)/g,"")  << 用于去除字符串"前-中-后"所有空格!
--- （解释） ---
str.replace(/reg/, sss)：正则替换 reg->sss
+：匹配一次以上（1+）
^：首（有些场合可以不要：在下面的"2"中，就没有这个）
$：末
()："组"（标记一个"子表达式" 开始到结束）
\s：空格
//g：g模式
|：或运算

【2】/Base[A-Z]\w+\.(vue|js)$/ << 匹配 BaseXXXX.vue或BaseZZZZ.js的文件
--- （解释） ---
[A-Za-z]：还是..写全的好!
\w：匹配包括下划线在内的任何单词字符

【FINAlly】证件号码 / 其他 / 正则集中案例 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
身份证号码:
  # 简单[只对数字]   var reg = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/;
  # 复杂[-1999]       var reg = /^((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|71|(8[12])|91)\d{4}((19\d{2}(0[13-9]|1[012])(0[1-9]|[12]\d|30))|(19\d{2}(0[13578]|1[02])31)|(19\d{2}02(0[1-9]|1\d|2[0-8]))|(19([13579][26]|[2468][048]|0[48])0229))\d{3}(\d|X|x)?$/
  # 超复杂[-2056]    var reg = /^((1[1-5])|(2[1-3])|(3[1-7])|(4[1-6])|(5[0-4])|(6[1-5])|71|(8[12])|91)\d{4}(((19|20)\d{2}(0[13-9]|1[012])(0[1-9]|[12]\d|30))|((19|20)\d{2}(0[13578]|1[02])31)|((19|20)\d{2}02(0[1-9]|1\d|2[0-8]))|(19([13579][26]|[2468][048]|0[48])0229)|(20([024][048]|[135][26])0229))\d{3}(\d|X|x)$/
支持4-18位字母或数字：
  # >>>>                var reg = /^[0-9a-zA-Z]{4,18}$/;
支持8个数字：
  # >>>>                var reg = /^[0-9]{8}$/;
支持3个字母加8个数字：
  # >>>>                var reg = /^[a-zA-Z]{3}[0-9]{12}$/;
支持7个数字 或 9个数字：
  # >>>>                var reg = /^(([0-9]{7})|([0-9]{9}))$/;
支持2到10个数字 混 大小写字母 混 汉字（!! 一个汉字占"1个"）：
  # >>>>                var reg = /^[0-9a-zA-Z\u4e00-\u9fa5]{2,10}$/;



