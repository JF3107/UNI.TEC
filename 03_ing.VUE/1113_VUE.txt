


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>>>>  1206 ，
========================================================================================

【自定义事件】

##  事件名：kebab-case（嗨粉[hyphen]命名）

##  自定义组件的v-model：
  **  v-model默认利用 名为value的prop[属性]、名为input的event[事件] <<<  针对input作为输入框的情况
         （若对于 checkbox复选、radio单选，需要手动设置model利用对象: prop/event）
  **  Vue.component("ccc", {中}), 有model分别对prop和event进行设置。

##  将原生事件绑定到组件：
  **  方法1：v-on:xxx.native  <<< 在一个组件的根元素直接监听一个原生事件
         （"方法1"只是部分有效、对于类似【<input>包裹在<label>中】的元素时.. 会失效）
  **  方法2：v-on="$listeners" <<< $listeners包含了作用在[ 这个组件 ]上所有的监听器
  **  方法2B：在组件构造中加入一个计算属性-"inputListeners"  >>> 代码如下：
     #  computed: {
     #    inputListeners: function () {
     #      var vm = this
     #      // "Object.assign" 将所有的对象合并为一个新对象
     #      return Object.assign({},
     #        // 我们从父级添加所有的监听器
     #        this.$listeners,
     #        // 然后我们添加自定义监听器，或重写一些监听器的行为
     #        {
     #          input: function (event) {
     #            vm.$emit('input', event.target.value)
     #          }
     #        }
     #      )
     #    }
     #  }

##  .sync 修饰符：









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>>>>  1122 ，
========================================================================================



模块系统

## 在模块系统（比如：Babel/Webpack的模块系统）中局部注册
建议创建一个"组件目录" >> 也就是components(文件夹)

## 基础组件（比如：按钮、输入框...）的自动化全局注册
（前提：使用webpack、VUE_CLI[内置webpack]）
用：require.context(①组件目录相对路径，②是否查询子目录，③文件名正则)，
例如：const requireComponent = require.context("./components",false,/Base[A-Z]\w+\.(vue|js)$/)
【后续处理（过程），完全不理解】

===============
【<<<<<<<<########%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%########>>>>>>>>】

Prop

## prop大小写
驼峰（JS）->短横小写（DOM）

## prop类型【prop可以是任何类型】
字符串数组形式：["xxxx",]
对象形式：
props：{ //prop类型：String、Number、Boolean、Array、Object
  xxxx：String
}

## 传递静态/动态prop
（静：title，动：v-bind:title[绑定]）
传数字：用"绑定"方式传 >> v-bind:xxx="1",这时传的是1、不是"1"
传布尔：用"绑定"方式传（同上）。另外，若只写不传、默认为true
传数组/对象：用"绑定"方式传（同上）
**传一个对象（比如 obj:{x:x,y:y}）全部属性[而不传这个对象]：用v-bind="obj"!!
>>>> 以上操作，直接把x、y绑定成独立prop

## 父-子prop.单向数据流
因此不要在子组件中擅改prop。可以：①以data用之 ②以computed算之

## prop验证
props（对象形式）对象的值（"键"即为prop名）、担当验证功能，如下：
①String, 单类型
②[String,Number]，多个可能的类型
③{type:String, default:"yo"}，类型+默认值
④{type:String, default:function(){return {msg:"yo"}}}，类型+默认(工厂函数获取)
⑤{validator:function(val){return xxx}}，自定义
** type=>原生构造函数：String,Number,Boolean,Array,Object,Data,Function,Symbol
** type=>还可以是一个自定义构造函数 Xxxx（前提：这个构造函数已经定义..）>>>>p1:Xxxx, 来验证p1是否是通过new Xxxx来创建

## 非prop的特性
①未知特性(属性)[且并没有在组件逻辑中定义]，会一并被添加到组件实例上。
②替换/合并已有的特性：
除class、style（合并）外，其他的属性值.冲突时>>都是替代[覆盖]。
③禁用特性继承：inheritAttrs: false （就这道这点，后面的..不知道）




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
>>>>  1120 ，
========================================================================================

【深入-组件注册】：

组件名：全小写 + 至少1个"-" （kebab-case）

全局注册：形如 Vue.component("xxx-yyy", {zzz}), 注册之后可以用在任何新创建的Vue根实例(new Vue)的模板中.

局部注册：用一个JS对象来定义组件，然后在new Vue()的components选项中定义想要使用的组件，如下：
  var CompoA = {...JS对象...}
  var CompoB = {...JS对象...}
  var CompoC = {...JS对象...}
  new Vue({
    el: "#app",
    components: {
      "compo-a": CompoA,
      "compo-b": CompoB
    }
  })

（局部注册的组件在其自组件中不可用，）如果希望compoA在compoB中可用，可以如下：
写法①：（普通）
  var CompoA = {...JS对象...}
  var CompoB = {
    components: {
      "compo-a": CompoA,
    },
    // ....
  }
写法②：（通过Babel/Webpack使用ES2015+模块）
  import CompoA from "./CompoA.vue"
  export default {
    components: {
      CompoA
    },
    // ....
  }


【1120， “模块系统”前】




（以上部分，将开始 "深入"  >> ）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pre 1120，VUE基础-组件
========================================================================================

Vue.component("组件名",  { ... })    ......... 定义组件
<div id="xxx">                       ......... DOM定位Vue根节点(实例)
  <组件名></组件名>
</div>
new Vue({el: "xxx"， ...})           ......... Vue 实例化
----------------------------
！注意： 组件可复用。
new Vue 中的data是个对象
组件定义中的data是个函数（带 return - 返回各data属性）


组件：可以复用的Vue实例
（new Vue创建的 [ el: "#xx" ] ，叫做 “根实例”）
**  Vue.component里的data，是一个function、并需要return（对象）！


组件必须先注册、才能被Vue识别。注册类型有：
全局注册、局部注册
Vue.component("compoNAME", {...})叫"全局注册"。全局、根实例下-全部可用


props，以数组形式聚集组件标签上所有的"属性"
(包括, 以v-for render的组件集[通常 以v-bind绑定属性])


每个组件必须只有一个根元素。(写组件模板时注意)


通过事件 向父级组件发送消息：
子级元素用 $emit()  >>  例如@click="$emit('eeee')"  >> 向上发送
父级组件用 监听事件 >>  例如@eeee="FUNCTION.."      >> 接收事件
----
使用事件抛出一个值：
自级元素抛出： $emit('事件名', 携带参数)
父级组件接收： 监听式内 》 用$event接收；方法.函数体内 》 作为参数接收


以下双式等价：
<input v-model="searchText" />
<input v-bind:value="searchText"
       v-on:input="searchText=$event.target.value" />
----
对一个组件用v-model：
<compo v-model="test"></compo>
那么组件props这样写：
props: ["value"]
那么组件template(含input)这样写：
<input v-bind:value="value"
       v-on:input="$emit('input', $event.target.value)"/>


插槽。<slot></slot>







